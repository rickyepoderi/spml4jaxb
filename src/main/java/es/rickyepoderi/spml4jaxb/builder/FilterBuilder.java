/* 
 * Copyright (c) 2015 ricky <https://github.com/rickyepoderi/spml4jaxb>
 * 
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *  See the file COPYING included with this distribution for more
 *  information.
 */
package es.rickyepoderi.spml4jaxb.builder;

import es.rickyepoderi.spml4jaxb.accessor.FilterAccessor;
import es.rickyepoderi.spml4jaxb.accessor.BaseRequestAccessor;
import es.rickyepoderi.spml4jaxb.msg.dsmlv2.AttributeDescription;
import es.rickyepoderi.spml4jaxb.msg.dsmlv2.AttributeValueAssertion;
import es.rickyepoderi.spml4jaxb.msg.dsmlv2.Filter;
import es.rickyepoderi.spml4jaxb.msg.dsmlv2.FilterSet;
import es.rickyepoderi.spml4jaxb.msg.dsmlv2.SubstringFilter;
import javax.xml.bind.JAXBElement;

/**
 * <p>This class is the builder for filters. A filter is the object that the
 * SPMLv2 standard manages to specify a search over the server in the DSML profile. 
 * The filter manages attribute conditions very similar to the conditions
 * given in an LDAP query filter. The idea of the builder is that you can
 * create easily atomic filters (equals, startsWith, and so on) and can
 * combine then to create complex filters (and, or, not).</p>
 * 
 * @author ricky
 */
public class FilterBuilder implements Builder<JAXBElement<Filter>, FilterAccessor> {
    
    /**
     * The internal filter type defined in DSML XSD file.
     */
    protected Filter filter = null;
    
    /**
     * Constructor using the internal filter type.
     * @param filter The internal filter type generated by JAXB
     */
    public FilterBuilder(Filter filter) {
        this.filter = filter;
    }
    
    /**
     * Constructor for an equals filter giving the name and the value
     * of the attribute (name=john).
     * @param name The name of the attribute 
     * @param value The value of the attribute
     * @return A filter builder
     */
    static public FilterBuilder equals(String name, String value) {
        Filter f = new Filter();
        AttributeValueAssertion ava = new AttributeValueAssertion();
        ava.setName(name);
        ava.setValue(value);
        f.setEqualityMatch(ava);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for a greater or equal filter giving the name and the value
     * of the attribute (name>=john).
     * @param name The name of the attribute 
     * @param value The value of the attribute
     * @return A filter builder
     */
    static public FilterBuilder greaterOrEqual(String name, String value) {
        Filter f = new Filter();
        AttributeValueAssertion ava = new AttributeValueAssertion();
        ava.setName(name);
        ava.setValue(value);
        f.setGreaterOrEqual(ava);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for a less or equal filter giving the name and the value
     * of the attribute (name&gt;=john).
     * @param name The name of the attribute 
     * @param value The value of the attribute
     * @return A filter builder
     */
    static public FilterBuilder lessOrEqual(String name, String value) {
        Filter f = new Filter();
        AttributeValueAssertion ava = new AttributeValueAssertion();
        ava.setName(name);
        ava.setValue(value);
        f.setLessOrEqual(ava);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for an approximation filter giving the name and the value
     * of the attribute (name~=john).
     * @param name The name of the attribute 
     * @param value The value of the attribute
     * @return A filter builder
     */
    static public FilterBuilder approxMatch(String name, String value) {
        Filter f = new Filter();
        AttributeValueAssertion ava = new AttributeValueAssertion();
        ava.setName(name);
        ava.setValue(value);
        f.setApproxMatch(ava);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for a present filter giving the name
     * of the attribute (name=*).
     * @param name The name of the attribute 
     * @return A filter builder
     */
    static public FilterBuilder present(String name) {
        Filter f = new Filter();
        AttributeDescription ad = new AttributeDescription();
        ad.setName(name);
        f.setPresent(ad);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for a starts with filter giving the name and the value
     * of the attribute (name=john*).
     * @param name The name of the attribute 
     * @param value The value of the attribute
     * @return A filter builder
     */
    static public FilterBuilder startsWith(String name, String value) {
        Filter f = new Filter();
        SubstringFilter sf = new SubstringFilter();
        sf.setName(name);
        sf.setInitial(value);
        f.setSubstrings(sf);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for a ends with filter giving the name and the value
     * of the attribute (name=*john).
     * @param name The name of the attribute 
     * @param value The value of the attribute
     * @return A filter builder
     */
    static public FilterBuilder endsWith(String name, String value) {
        Filter f = new Filter();
        SubstringFilter sf = new SubstringFilter();
        sf.setName(name);
        sf.setFinal(value);
        f.setSubstrings(sf);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for a contains filter giving the name and the value
     * of the attribute (name=*john*).
     * @param name The name of the attribute 
     * @param value The value of the attribute
     * @return A filter builder
     */
    static public FilterBuilder contains(String name, String value) {
        Filter f = new Filter();
        SubstringFilter sf = new SubstringFilter();
        sf.setName(name);
        sf.getAny().add(value);
        f.setSubstrings(sf);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for an and filter giving the members of the and as another
     * filters.
     * @param filter List of filter builders to use as the and
     * @return A filter builder
     */
    static public FilterBuilder and(FilterBuilder... filter) {
        Filter f = new Filter();
        FilterSet fs = new FilterSet();
        for (FilterBuilder fb: filter) {
            fs.getFilterGroup().add(fb.buildFilterSet());
        }
        f.setAnd(fs);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for an or filter giving the members of the and as another
     * filters.
     * @param filter List of filter builders to use as the or
     * @return A filter builder
     */
    static public FilterBuilder or(FilterBuilder... filter) {
        Filter f = new Filter();
        FilterSet fs = new FilterSet();
        for (FilterBuilder fb: filter) {
            fs.getFilterGroup().add(fb.buildFilterSet());
        }
        f.setOr(fs);
        return new FilterBuilder(f);
    }
    
    /**
     * Constructor for a not filter giving the negated member filter.
     * @param filter The filter to be negated
     * @return A filter builder
     */
    static public FilterBuilder not(FilterBuilder filter) {
        Filter f = new Filter();
        f.setNot(filter.filter);
        return new FilterBuilder(f);
    }
    
    /**
     * This method create the JAXB element that corresponds to the internal filter
     * set. Depending the operation/comparison the JAXB element is different.
     * @return The JAXB element that corresponds to this filter
     */
    protected JAXBElement buildFilterSet() {
        FilterAccessor accessor = BaseRequestAccessor.accessorForFilter(filter);
        if (accessor.isEquals()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetEqualityMatch(filter.getEqualityMatch());
        } else if (accessor.isGreaterOrEqual()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetGreaterOrEqual(filter.getGreaterOrEqual());
        } else if (accessor.isLessOrEqual()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetLessOrEqual(filter.getLessOrEqual());
        } else if (accessor.isApproxMatch()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetApproxMatch(filter.getApproxMatch());
        } else if (accessor.isPresent()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetPresent(filter.getPresent());
        } else if (accessor.isStartsWith() || accessor.isEndsWith() || accessor.isContains()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetSubstrings(filter.getSubstrings());
        } else if (accessor.isNot()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetNot(filter.getNot());
        } else if (accessor.isAnd()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetAnd(filter.getAnd());
        } else if (accessor.isOr()) {
            return RequestBuilder.dsmlv2ObjectFactory.createFilterSetOr(filter.getOr());
        } else {
            throw new IllegalStateException("Invalid filter!!!");
        }
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public JAXBElement<Filter> build() {
        return RequestBuilder.dsmlv2ObjectFactory.createFiler(filter);
    }
    
    /**
     * Method that creates a not Filter over the current filter.
     * @return The not filter of this one
     */
    public FilterBuilder not() {
        return FilterBuilder.not(this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public FilterAccessor asAccessor() {
        return new FilterAccessor(filter);
    }
    
}
