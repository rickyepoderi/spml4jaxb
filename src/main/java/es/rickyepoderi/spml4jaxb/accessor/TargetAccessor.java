/* 
 * Copyright (c) 2015 ricky <https://github.com/rickyepoderi/spml4jaxb>
 * 
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *  See the file COPYING included with this distribution for more
 *  information.
 */
package es.rickyepoderi.spml4jaxb.accessor;

import es.rickyepoderi.spml4jaxb.builder.ListTargetsRequestBuilder;
import es.rickyepoderi.spml4jaxb.builder.TargetBuilder;
import es.rickyepoderi.spml4jaxb.msg.core.CapabilitiesListType;
import es.rickyepoderi.spml4jaxb.msg.core.CapabilityType;
import es.rickyepoderi.spml4jaxb.msg.core.SchemaEntityRefType;
import es.rickyepoderi.spml4jaxb.msg.core.SchemaType;
import es.rickyepoderi.spml4jaxb.msg.core.TargetType;
import java.util.ArrayList;
import java.util.List;

/**
 * <p>Accessor for a target as returned in the ListTargets response. Each target
 * is the definition or information that the server gives about its SPMLv2
 * characteristics. In general the information that a target contains is the
 * following:</p>
 * 
 * <ol>
 * <li>The target identifier.</li>
 * <li>The target should follow a profile. The profile describes how the data
 * should be represented inside the target. SPMLv2 defines two profiles:
 * XSD (data is managed using XML information based on a custom XSD file) and
 * DSML (data is managed using attributes more or less like in an LDAP 
 * repository).</li>
 * <li>The target should contain the schema of the data managed. In XSD profile
 * the schema is the XSD definition file of the interchanged objects. In DSML
 * profile the schema is the list of attributes and types of objects managed
 * (similar to objectclasses and attributes in an LDAP server).</li>
 * <li>Finally the list of capabilities supported by the target are exposed in
 * the response. SPMLv2 groups operations in different capabilities (the core
 * capability -CRUD- should be implemented by all SPMLv2 compatible servers but 
 * the rest of them are optional and only needed to cover more specific 
 * characteristics), the target information should inform what optional
 * capabilities are supported.</li>
 * </ol>
 * 
 * <p>The schema is managed separated with another accessor/builder pair.</p>
 * 
 * @author ricky
 */
public class TargetAccessor implements Accessor<TargetType, TargetAccessor, TargetBuilder>{
    
    /**
     * The internal Target type as defined in SPMLv2 XSD file and generated by JAXB.
     */
    protected TargetType target;
    
    /**
     * Constructor of a target accessor using the internal type.
     * @param target The internal JAXB target type.
     */
    public TargetAccessor(TargetType target) {
        this.target = target;
    }
    
    /**
     * Getter for the target identifier.
     * @return The target identifier
     */
    public String getTargetId() {
        return target.getTargetID();
    }
    
    /**
     * Getter for the profile of the target.
     * @return The profile URI of the target
     */
    public String getProfile() {
        return target.getProfile();
    }
    
    /**
     * Checks if the profile of the target is SDML.
     * @return true if the profile URI is the DSML one, false otherwise
     */
    public boolean isDsml() {
        return ListTargetsRequestBuilder.DSML_PROFILE_URI.equals(getProfile());
    }
    
    /**
     * Checks if the profile of the target is XSD.
     * @return true if the profile URI is the XSD one, false otherwise
     */
    public boolean isXsd() {
        return ListTargetsRequestBuilder.XSD_PROFILE_URI.equals(getProfile());
    }
    
    /**
     * Return the schema accessor(s) for the schema(s) defined in the target.
     * @return The array of schema accessors or empty array
     */
    public SchemaAccessor[] getSchemas() {
        List<SchemaAccessor> res = new ArrayList<>();
        for (SchemaType schema: target.getSchema()) {
            res.add(new SchemaAccessor(schema));
        }
        return res.toArray(new SchemaAccessor[0]);
    }
    
    /**
     * Checks for a capability URI. This method checks if the target has
     * the specified capability as defined.
     * @param uri The capability to check
     * @return true if the target has the capability for any object, false otherwise
     */
    public boolean hasCapability(String uri) {
        return hasCapabilityFor(uri, null);
    }
    
    /**
     * Checks for a capability URI for a specified type. This method checks
     * if the specified entity has the property. If null entity is passed,
     * true is returned if the capability is defined for any entity.
     * @param uri The property URI to check
     * @param entity The entity that applies the capability (can be null)
     * @return true if the entity has the capability, false otherwise
     */
    public boolean hasCapabilityFor(String uri, String entity) {
        CapabilitiesListType capabilities = target.getCapabilities();
        if (capabilities != null) {
            for (CapabilityType capability: capabilities.getCapability()) {
                if (uri.equals(capability.getNamespaceURI())) {
                    if (entity == null) {
                        // generic capability is checked
                        return true;
                    } else if (capability.getAppliesTo().isEmpty()) {
                        // if no entity is defined, it is generic for all entities
                        return true;
                    } else {
                        // check if the entity is specified
                        for (SchemaEntityRefType ref : capability.getAppliesTo()) {
                            if (entity.equals(ref.getEntityName())) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    
    /**
     * Checker for the async capability in the target.
     * @return true if the target has the async capability, false otherwise
     */
    public boolean hasAsyncCapability() {
        return hasCapability(BaseRequestAccessor.SPML_CAPABILITY_ASYNC_URI);
    }
    
    /**
     * Checker for the password capability in the target.
     * @return true if the target has the password capability for any entity, false otherwise
     */
    public boolean hasPasswordCapability() {
        return hasCapability(BaseRequestAccessor.SPML_CAPABILITY_PASSWORD_URI);
    }
    
    /**
     * Checker for the password capability for a specific entity in the target.
     * @param entity entity to check (if null the method returns true if the capability is set for any entity)
     * @return true if the capability is defined for the entity, false otherwise
     */
    public boolean hasPasswordCapabilityFor(String entity) {
        return hasCapabilityFor(BaseRequestAccessor.SPML_CAPABILITY_PASSWORD_URI, entity);
    }
    
    /**
     * Checker for the suspend capability in the target.
     * @return true if the target has the suspend capability for any entity, false otherwise
     */
    public boolean hasSuspendCapability() {
        return hasCapability(BaseRequestAccessor.SPML_CAPABILITY_SUSPEND_URI);
    }
    
    /**
     * Checker for the suspend capability for a specific entity in the target.
     * @param entity entity to check (if null the method returns true if the capability is set for any entity)
     * @return true if the capability is defined for the entity, false otherwise
     */
    public boolean hasSuspendCapabilityFor(String entity) {
        return hasCapabilityFor(BaseRequestAccessor.SPML_CAPABILITY_SUSPEND_URI, entity);
    }
    
    /**
     * Checker for the bulk capability in the target.
     * @return true if the target has the async capability, false otherwise
     */
    public boolean hasBulkCapability() {
        return hasCapability(BaseRequestAccessor.SPML_CAPABILITY_BULK_URI);
    }
    
    /**
     * Checker for the batch capability in the target.
     * @return true if the target has the async capability, false otherwise
     */
    public boolean hasBatchCapability() {
        return hasCapability(BaseRequestAccessor.SPML_CAPABILITY_BATCH_URI);
    }
    
    /**
     * Checker for the updates capability in the target.
     * @return true if the target has the async capability, false otherwise
     */
    public boolean hasUpdatesCapability() {
        return hasCapability(BaseRequestAccessor.SPML_CAPABILITY_UPDATES_URI);
    }
    
    /**
     * Checker for the search capability in the target.
     * @return true if the target has the async capability, false otherwise
     */
    public boolean hasSearchCapability() {
        return hasCapability(BaseRequestAccessor.SPML_CAPABILITY_SEARCH_URI);
    }
    
    /**
     * Checker for the search capability for a specific entity in the target.
     * @param entity entity to check (if null the method returns true if the capability is set for any entity)
     * @return true if the capability is defined for the entity, false otherwise
     */
    public boolean hasSearchCapabilityFor(String entity) {
        return hasCapabilityFor(BaseRequestAccessor.SPML_CAPABILITY_SEARCH_URI, entity);
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
        String nl = System.getProperty("line.separator");
        StringBuilder sb = new StringBuilder("  Target ").append(" ")
                .append(getTargetId()).append(" - ").append(getProfile())
                .append(nl);
        for (SchemaAccessor s : getSchemas()) {
            sb.append(s);
        }
        return sb.toString();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public TargetType getInternalType() {
        return this.target;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public TargetBuilder toBuilder() {
        return new TargetBuilder(this.target);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public TargetAccessor asAccessor(TargetType type) {
        return new TargetAccessor(type);
    }
}